#include "view.h"
#include "ui_view.h"
#include "common.h"
#include <QDebug>
char filename[40][20];
int i_up = 1, i_down = 0;
view::view(QWidget *parent, int playernumber, int minenumber):
    QMainWindow(parent),
    ui(new Ui::view),
  player_num(playernumber),
  mine_num(minenumber)
{
    loadImg();
    ui->setupUi(this);


    vm_ = viewmodelinit();

    player_num=1;

    if(player_num==1)
    {
        role_x.push_back(1266/2-60);
        role_y.push_back(10);
        role_coin.push_back(0);
        hook_x.push_back(1266/2-20);
        hook_y.push_back(100);
        hook_state.push_back(9);
        hook_len.push_back(50);
        hook_dir.push_back(LEFT);
        hook_endx.push_back(1266/2-20);
        hook_endy.push_back(120);
        hook_angle.push_back(0);
    }
    else if(player_num==2)
    {
        role_x.push_back(1266/2-120);
        role_y.push_back(10);
        role_coin.push_back(0);
        hook_x.push_back(1266/2-80);
        hook_y.push_back(100);
        hook_state.push_back(9);
        hook_len.push_back(50);
        hook_dir.push_back(LEFT);
        hook_endx.push_back(1266/2-80);
        hook_endy.push_back(120);
        hook_angle.push_back(0);

        role_x.push_back(1266/2+120);
        role_y.push_back(10);
        role_coin.push_back(0);
        hook_x.push_back(1266/2+160);
        hook_y.push_back(100);
        hook_state.push_back(9);
        hook_len.push_back(50);
        hook_dir.push_back(LEFT);
        hook_endx.push_back(1266/2+160);
        hook_endy.push_back(120);
        hook_angle.push_back(0);
    }
    else
    {
        role_x.push_back(1266/2-260);
        role_y.push_back(10);
        role_coin.push_back(0);
        hook_x.push_back(1266/2-220);
        hook_y.push_back(100);
        hook_state.push_back(9);
        hook_len.push_back(50);
        hook_dir.push_back(LEFT);
        hook_endx.push_back(1266/2-220);
        hook_endy.push_back(120);
        hook_angle.push_back(0);

        role_x.push_back(1266/2-60);
        role_y.push_back(10);
        role_coin.push_back(0);
        hook_x.push_back(1266/2-20);
        hook_y.push_back(100);
        hook_state.push_back(9);
        hook_len.push_back(50);
        hook_dir.push_back(LEFT);
        hook_endx.push_back(1266/2-20);
        hook_endy.push_back(120);
        hook_angle.push_back(0);

        role_x.push_back(1266/2+140);
        role_y.push_back(10);
        role_coin.push_back(0);
        hook_x.push_back(1266/2+180);
        hook_y.push_back(100);
        hook_state.push_back(9);
        hook_len.push_back(50);
        hook_dir.push_back(LEFT);
        hook_endx.push_back(1266/2+180);
        hook_endy.push_back(120);
        hook_angle.push_back(0);
    }



}

viewmodelcommand* view::viewmodelinit(){
    vm_ = new viewmodelcommand()
    
    
}

view::~view()
{
    delete ui;
}

void view::loadImg()
{
    for (int i = 0; i < 20; i++)
            sprintf(filename[i], "G:/images/%d", i);
        sprintf(filename[20], "G:/images/bk");
        for (int i = 21; i < 40; i++)
            sprintf(filename[i], "G:/images/%d", i);
}

QPixmap view::rotateImageWithTransform(const QPixmap &src, int angle)
{
    QMatrix matri;
        //迁移到中心
        matri.translate(src.width()/2.0,src.height()/2.0);
        //中心旋转
        matri.rotate(angle);
        //回退中心
        matri.translate(-src.width()/2.0,-src.height()/2.0);
        //执行坐标映射变化
        //旋转后图像大小变化了 需要提前进行裁剪 如果在旋转后裁剪
        //则需要计算使用三角函数计算
        //中心偏移
        int cubeWidth = qMin(src.width(),src.height());
        QRect cubeRect(0,0,cubeWidth,cubeWidth);
        cubeRect.moveCenter(src.rect().center());
        qDebug()<<" cube "<<cubeRect
               <<" src rect "<<src.rect();

        auto retImg = src.copy(cubeRect);
        retImg = retImg.transformed(matri,Qt::SmoothTransformation);
        return retImg;
}

void view::paintEvent(QPaintEvent *event)
{
    QPainter painter(this);
    //绘制背景
    this->resize( QSize( WIDTH, HEIGHT ));
    QPixmap pix;
    pix.load(filename[20]);
    painter.drawPixmap(0,140,WIDTH,HEIGHT-140,pix);
    pix.load(filename[15]);
    painter.drawPixmap(0,0,WIDTH,140,pix);

    //绘制人物
    for(int i=0;i<player_num;i++)
    {
        if (hook_state[i] == M_NORMAL)
            {
                pix.load(filename[i_roleDown]);
                painter.drawPixmap(role_x[i],role_y[i],pix.width(),pix.height(),pix);
            }
            else
            {
                if (i_down%20<10)
                {
                    pix.load(filename[i_roleDown]);
                    painter.drawPixmap(role_x[i],role_y[i],pix.width(),pix.height(),pix);
                    i_down++;
                }
                else
                {
                    pix.load(filename[i_roleUp]);
                    painter.drawPixmap(role_x[i],role_y[i],pix.width(),pix.height(),pix);
                    i_down++;
                }
            }
    }

    //输出钱
    int money;
    for(int i=0;i<player_num;i++)
        money += role_coin[i];
    QFont font;
    painter.setPen(QColor(Qt::black));
    font.setPointSize(30);
    painter.setFont(font);
    QTransform transform;
    // 获取字体信息
    QFontInfo info = painter.fontInfo();
    info.family();
    info.italic();
    // 转换
    painter.setTransform(transform);
    painter.drawText(rect(), QStringLiteral("金钱："));
    QString s = QString::number(money);
    painter.drawText(150, 42, s);
    for(int i=0;i<player_num;i++)
    {
        painter.setFont(font);
        font.setPointSize(20);
        s = QString::number(role_coin[i]);
        painter.drawText(role_x[i]+40,role_y[i]*16, s);
    }
    //绘制钩子
    QPen pen;
    painter.setPen(QPen(Qt::black,3));
    pix.load(filename[25]);
    for(int i=0;i<player_num;i++)
    {
        painter.drawLine(QPoint(hook_x[i],hook_y[i]),QPoint(hook_endx[i],hook_endy[i]));
        pix=rotateImageWithTransform(pix, hook_angle[i]);
        painter.drawPixmap(hook_endx[i] - 13, hook_endy[i] - 12,pix);
    }

    //画金子
//    for (int i = 0; i < MINE_NUM; i++) {
//            if (mine_flag[i] == true) {
//                switch (mine_type[i]) {
//                case LITTLEGOLD:
//                    pix.load(filename[i_goldsmall]);
//                    painter.drawPixmap(mine_x[i], mine_y[i],pix);
//                    break;
//                case MIDGOLD:
//                    pix.load(filename[i_goldmiddle]);
//                    painter.drawPixmap(mine_x[i], mine_y[i],pix);
//                    break;
//                case BIGGOLD:
//                    pix.load(filename[i_goldbig]);
//                    painter.drawPixmap(mine_x[i], mine_y[i],pix);
//                    break;
//                case LITTLESTONE:
//                    pix.load(filename[i_stonesmall]);
//                    painter.drawPixmap(mine_x[i], mine_y[i],pix);
//                    break;
//                case BIGSTONE:
//                    pix.load(filename[i_stonebig]);
//                    painter.drawPixmap(mine_x[i], mine_y[i],pix);
//                    break;
//                case MONEY:
//                    pix.load(filename[i_money]);
//                    painter.drawPixmap(mine_x[i], mine_y[i],pix);
//                    break;
//                case DIAMOND:
//                    pix.load(filename[i_diamond]);
//                    painter.drawPixmap(mine_x[i], mine_y[i],pix);
//                    break;
//                }
//            }
//        }
}
 void view::sethookposition(QVector<double>endx,QVector<double>endy,QVector<int>state,QVector<double>len,QVector<double>angle,QVector<int>dir)
 {
     hook_endx=endx;
     hook_endy=endy;
     hook_state=state;
     hook_len=len;
     hook_angle=angle;
     hook_dir=dir;
 }

 void view::setmine(QVector<double>x,QVector<double>y,QVector<int>type,QVector<int>flag)
 {
     mine_x=x;
     mine_y=y;
     mine_type=type;
     mine_flag=flag;
 }

